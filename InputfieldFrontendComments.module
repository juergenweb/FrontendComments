<?php
    namespace ProcessWire;

/*
 * Input field for the comments
 * This class collects the input data in the backend
 *
 * Created by Jürgen K.
 * https://github.com/juergenweb
 * File name: InputfieldComments.php
 * Created: 24.12.2024
 *
 */

    use ProcessWire\InputfieldFrontendComments;

class InputfieldFrontendComments extends Inputfield
{

    protected array $frontendFormsConfig = [];


    public function __construct()
    {
        parent::__construct();

        // grab configuration values from the FrontendForms module
        $this->frontendFormsConfig = FieldtypeFrontendComments::getFrontendFormsConfigValues();



    }

    /**
     * Get the info data about this input field
     * @return array
     */
    public static function getModuleInfo(): array
    {
        return array(
            'title' => __('Inputfield FrontendComments', __FILE__),
            'summary' => __('Inputfield for managing comments on a page.',
                __FILE__),
            'href' => 'https://github.com/juergenweb/FieldtypeFrontendComments',
            'icon' => 'comment',
            'permanent' => false,
            'version' => '1.0.0',
            'requires' => [
                'FieldtypeFrontendComments',
                'PHP>=8.0',
                'ProcessWire>=3'
            ],
            'author' => 'Jürgen Kern'
        );
    }

    /**
     * Array containing the texts for each status
     * @return array
     */
    public static function statusTexts(): array
    {
        return [
            __('pending approval'),
            __('approved'),
            __('SPAM'),
            __('SPAM, but has replies')
        ];
    }

    /**
     * Render the comment list in the backend
     * @return string
     * @throws \ProcessWire\WireException
     * @throws \ProcessWire\WirePermissionException
     */
    public function ___render(): string
    {
        $field = $this->wire('fields')->get($this->get('name'));
        bd($field->input_fc_website);

        $fieldset = $this->modules->get('InputfieldFieldset');
        $fieldset->label = $this->_('Comments');

        // Add text that there are no comments at the moment
        if (count($this->value) === 0) {
            $noComments = $this->modules->get('InputfieldMarkup');
            $noComments->set('markupText', $this->_('There are no comments at the moment.'));
            $fieldset->add($noComments);
        } else {

            // list of comments
            $i = 1;

            foreach ($this->value as $comment) {

                $commentfieldset = $this->modules->get('InputfieldFieldset');
                $commentfieldset->set('entityEncodeText', false);
                $commentfieldset->set('label', strtoupper(self::statusTexts()[$comment->status]) . ': ' . $this->_('Comment') . ' #' . $i . ' ' .
                    sprintf($this->_('Posted on: %s'), $this->wire('datetime')->date($this->frontendFormsConfig['input_dateformat'], $comment->created)));
                $commentfieldset->set('collapsed', true);

                // comment text
                $text = $this->modules->get('InputfieldTextarea');
                $text->label = $this->_('Comment');
                $text->attr('id|name', $this->name . '_text_' . $comment->id);
                $text->attr('value', $comment->text);
                $commentfieldset->add($text);

                $colwidth = '25';
                // email
                $email = $this->modules->get('InputfieldEmail');
                $email->label = $this->_('Email');
                $email->attr('id|name', $this->name . '_email_' . $comment->id);
                $email->attr('value', $comment->email);
                $email->set('columnWidth', $colwidth);
                $commentfieldset->add($email);

                // author
                $author = $this->modules->get('InputfieldText');
                $author->label = $this->_('Author');
                $author->attr('id|name', $this->name . '_author_' . $comment->id);
                $author->attr('value', $comment->author);
                $author->set('columnWidth', $colwidth);
                $commentfieldset->add($author);

                // status
                $status = $this->modules->get('InputfieldSelect');
                $status->label = $this->_('Status');
                $status->attr('id|name', $this->name . '_status_' . $comment->id);
                $status->attr('value', $comment->status);
                $status->addOption(FieldtypeFrontendComments::pendingApproval, $this->_('Pending approval'), ['disabled' => 'disabled']);
                $status->addOption(FieldtypeFrontendComments::approved, $this->_('Approved'));
                if ($comment->getReplies()->count) {
                    $status->addOption(FieldtypeFrontendComments::spamReplies, $this->_('SPAM'));
                } else {
                    $status->addOption(FieldtypeFrontendComments::spam, $this->_('SPAM'));
                }
                $status->addOption('delete', $this->_('Delete the comment'));
                $status->set('notes', $this->_('Status "Pending approval" cannot be selected. If you want to delete the comment, select "Delete the comment" and save the page.'));
                $status->set('columnWidth', $colwidth);
                $commentfieldset->add($status);

                // website
                $website = $this->modules->get('InputfieldURL');
                $website->label = $this->_('Homepage');
                $website->attr('id|name', $this->name . '_website_' . $comment->id);
                $website->attr('value', $comment->website);
                $website->set('columnWidth', $colwidth);
                $commentfieldset->add($website);

                // moderation feedback textfield
                $feedback = $this->modules->get('InputfieldCKEditor');
                $feedback->set('label', $this->_('Moderation feedback'));
                $feedback->attr('id|name', $this->name . '_moderation_feedback_' . $comment->id);
                $feedback->attr('value', $comment->moderation_feedback);
                $feedback->set('description', $this->_('Enter a feedback to a comment'));
                $feedback->set('notes', $this->_('This text will be displayed directly below the comment.'));
                $commentfieldset->add($feedback);

                $fieldset->add($commentfieldset);
                $i++;
            }
        }

        return $fieldset->render();
    }

    /**
     * Process input for the comment inputs
     * @param \ProcessWire\WireInputData $input
     * @return \ProcessWire\InputfieldFrontendComments
     */
    public function ___processInput(WireInputData $input): InputfieldFrontendComments
    {
        $n = 1;

        // names of the various form fields
        $names = array(
            'author',
            'email',
            'status',
            'parent_id',
            'text',
            'moderation_feedback'
        );

        // loop through each comment
        foreach ($this->value as $comment) {

            $comment->setTrackChanges();

            // create the names of the input fields for each comment form
            $data = array();
            foreach ($names as $name) {
                $inputName = $this->name . "_" . $name . "_" . $comment->id;
                $value = isset($input[$inputName]) ? $input[$inputName] : '';
                $data[$name] = $value;
            }

            // loop through each input field of the comment
            foreach ($data as $key => $value) {

                // check if the input field value has been changed
                if (($value || $key == 'status') && $comment->$key != $value) {
                    $comment->$key = $value; // set the new value
                    $this->message(sprintf($this->_('Updated %s for comment #%d'), $key, $n));
                    $comment->trackChange($key);
                    $this->value->trackChange('update'); // set a track change value for all comments

                }
            }
            $n++;
        }
        return $this;

    }

}
