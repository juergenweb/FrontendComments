<?php
    declare(strict_types=1);

    namespace ProcessWire;

    /*
     * Class to create a simple comments manager to manage all comments in one place
     * A new custom admin page will be created
     * This page includes a statistic area about all comment fields installed and
     * a filterable table containing all comments of a certain FrontendComments field
     * Modal window support for editing multiple values of a certain comment
     *
     */

    use Exception;
    use FrontendComments\CommentArray;
    use FrontendComments\Comment;
    use FrontendComments\configValues;
    use FrontendComments\Notifications;
    use PDO;

    // include all necessary files
    $dirname = dirname(__FILE__);
    require_once($dirname . "/traits/configValues.php");

    class FrontendCommentsAdmin extends Process
    {

        use configValues;

        // Declare all properties
        protected int $defaultNumber = 20; // The default number of comments to display in the table
        protected WireArray $commentFields; // Wire array containing all FrontendComments field objects
        protected array $frontendFormsConfig = [];
        protected Field $field; // A single FrontendComments field;

        /**
         * @throws \ProcessWire\WireException
         * @throws \ProcessWire\WirePermissionException
         */
        public function __construct()
        {

            parent::__construct();

            // get all FrontendComments fields site wide as a WireArray
            $this->commentFields = $this->getCommentFields();

            if ($this->commentFields->count)  {

                // Get all FrontendForms configuration values
                $this->frontendFormsConfig = $this->getFrontendFormsConfigValues();

                // As the default comment field on page load, take the first one inside the WireArray
                $this->field = $this->commentFields->first();

            }

        }

        /**
         * Array containing the module info data
         * @return array
         */
        public static function getModuleinfo(): array
        {
            return [
                'title' => __('Comments manager', __FILE__),
                'summary' => __('A custom page for the FrontendComments module to manage all comments in one place', __FILE__),
                'author' => 'JÃ¼rgen Kern',
                'version' => '1.0.0',
                'icon' => 'comments',
                'permanent' => false,
                'page' => [
                    'name' => 'comments-manager',
                    'title' => __('FrontendComments manager', __FILE__),
                    'parent' => 'setup'
                ],
            ];
        }

        /**
         * @throws \ProcessWire\WireException
         */
        public function init(): void
        {
            parent::init();

            // add CSS and JS to the backend
            $version = $this->getModuleInfo()['version'] . '-' . time();
            $this->wire('config')->styles->add($this->wire('config')->urls->{$this->className} . 'backend-assets/frontendcommentsadmin.css?v=' . $version . '&time=' . time());
            $this->wire('config')->scripts->add($this->wire('config')->urls->{$this->className} . 'backend-assets/frontendcommentsadmin.js?v=' . $version . '&time=' . time());

            // activate modal windows for full comment edit
            wire('modules')->get('JqueryUI')->use('modal');
        }

        /**
         * Create and render the edit form for the comment inside the modal window
         * @return string|null
         * @throws \ProcessWire\WireException
         * @throws \ProcessWire\WirePermissionException
         */
        public function ___executeDetail(): string|null
        {
            // Set all required querystring keys
            $requiredKeys = ['commentid', 'pageid', 'fieldid'];

            // Get all query string values from the GET request
            $query = wire('input')->queryStringClean(['validNames' => $requiredKeys, 'entityEncode' => false]);
            parse_str($query, $res);

            // check if there are the 3 required querystrings present
            if (!count(array_intersect_key(array_flip($requiredKeys), $res)) === count($requiredKeys)) {
                return '<p>' . $this->_('Sorry, but something went wrong. Too less parameters will be sent via this request.') . '</p>';
            }

            $out = '';

            // Get different values
            $commentID = (int)$res['commentid'];
            $pageID = (int)$res['pageid'];
            $fieldID = (int)$res['fieldid'];

            $page = wire('pages')->get($pageID);
            $field = wire('fields')->get($fieldID);
            $fieldName = $field->name;
            $comments = $page->$fieldName; // get the CommentsArray of this field
            $table = $field->getTable();
            $comment = $comments->findOne($commentID);

            // check if comment exists
            if ($comment) {

                // create a new admin form to change comment values
                $form = wire('modules')->get('InputfieldForm');
                $form->action = wire('input')->url . '?commentid=' . $commentID . '&pageid=' . $pageID . '&fieldid=' . $fieldID;
                $form->method = "post";
                $form->attr("id+name", 'detail-comment-form');

                // create author field
                $fieldAuthor = wire('modules')->get("InputfieldText");
                $fieldAuthor->label = $this->_('Author');
                $fieldAuthor->attr('id+name', 'detailname');
                $fieldAuthor->value = $comment->getAuthor();
                $fieldAuthor->required = 1;
                $form->append($fieldAuthor); // append the field to the form

                // create email field
                $fieldEmail = wire('modules')->get("InputfieldEmail");
                $fieldEmail->label = $this->_('Email');
                $fieldEmail->attr('id+name', 'detailemail');
                $fieldEmail->value = $comment->getEmail();
                $fieldEmail->required = 1;
                $form->append($fieldEmail); // append the field

                // create comment text field
                $fieldText = wire('modules')->get("InputfieldTextarea");
                $fieldText->label = $this->_('Comment');
                $fieldText->attr('id+name', 'detailtext');
                $fieldText->value = $comment->getText();
                $fieldText->required = 1;
                $form->append($fieldText); // append the field

                // create status field
                $fieldStatus = wire('modules')->get("InputfieldSelect");
                $fieldStatus->label = $this->_('Status');
                $fieldStatus->attr('id+name', 'detailstatus');
                $statusOptions = [
                    FieldtypeFrontendComments::pendingApproval => $this->_('Waiting for approval'),
                    FieldtypeFrontendComments::approved => $this->_('Approved'),
                    FieldtypeFrontendComments::spam => $this->_('SPAM'),
                    FieldtypeFrontendComments::spamReplies => $this->_('SPAM, but has children')
                ];
                $fieldStatus->addOptions($statusOptions);
                $fieldStatus->attr('value', $comment->status);
                $fieldStatus->required = 1;
                $form->append($fieldStatus); // append the field

                // create star rating field
                $fieldRating = wire('modules')->get("InputfieldSelect");
                $fieldRating->label = $this->_('Star rating');
                $fieldRating->attr('id+name', 'detailrating');
                $fieldRating->addOption(1, sprintf($this->_('%s star'), '1'));
                $fieldRating->addOption(2, sprintf($this->_('%s stars'), '2'));
                $fieldRating->addOption(3, sprintf($this->_('%s stars'), '3'));
                $fieldRating->addOption(4, sprintf($this->_('%s stars'), '4'));
                $fieldRating->addOption(5, sprintf($this->_('%s stars'), '5'));
                $fieldRating->attr('value', $comment->stars);
                $form->append($fieldRating); // append the field

                // submit button!
                $submit = wire('modules')->get("InputfieldSubmit");
                $submit->attr("value", $this->_('Save the comment'));
                $submit->attr("id+name", "submitdetail");
                $form->append($submit);

                // the form was submitted so we process the form
                if (wire('input')->post->submitdetail) {

                    // set different values
                    $session = wire('session');
                    $input = wire('input');
                    $database = wire('database');
                    $sanitizer = wire('sanitizer');

                    // sanitize all POST values before
                    $input->post->detailname = $sanitizer->text($input->post->detailname);
                    $input->post->detailemail = $sanitizer->text($input->post->detailemail);
                    $input->post->detailtext = $sanitizer->textarea($input->post->detailtext);
                    $input->post->detailstatus = $sanitizer->int($input->post->detailstatus);
                    $input->post->detailrating = $sanitizer->int($input->post->detailrating, ['blankValue' => '']);

                    // user submitted the form, process it and check for errors
                    $form->processInput($input->post);

                    if ($form->getErrors()) {
                        // the form is processed and populated but contains errors
                        $out .= '<p>' . $this->_('There are errors! Please check your inputs once more.') . '</p>';
                        $out .= $form->render();
                    } else {

                        // try to save certain values form the edit form to the database
                        try {

                            $sql = "UPDATE $table SET author=:author,email=:email,data=:data,status=:status,stars=:stars,spam_update=:update_spam WHERE id=$commentID";
                            $query = $database->prepare($sql);

                            // set value for the spam_update column
                            $spam_update = NULL;

                            // check if the status has been set to spam
                            if ($input->post->detailstatus == '2')  {
                                $spam_update = time();
                            }
                            // check if comment has children at the moment - if yes set spam_update to null again
                            if (($comment->getReplies()->count) && ($input->post->detailstatus == '2')) {
                                $spam_update = NULL;
                                $input->post->detailstatus = '3'; // set new status to 3 (SPAM, but has children) to prevent deletion of the comment
                            }



                            $query->bindValue(':author', $input->post->detailname);
                            $query->bindValue(':email', $input->post->detailemail);
                            $query->bindValue(':data', $input->post->detailtext);
                            $query->bindValue(':status', $input->post->detailstatus, PDO::PARAM_INT);
                            $query->bindValue(':stars', $input->post->detailrating, PDO::PARAM_INT);
                            $query->bindValue(':update_spam', $spam_update, PDO::PARAM_INT);

                            // execute the query to save the comment in the database
                            if ($query->execute()) {

                                // send notification email on status change if enabled inside the module configuration
                                if ($comment->status != $input->post->detailstatus) {
                                    if (in_array($input->post->detailstatus, [FieldtypeFrontendComments::approved, FieldtypeFrontendComments::spam])) {
                                        $notification = new Notifications($comments);
                                        // add new status to the comment
                                        $comment->status = $input->post->detailstatus;
                                        $notification->sendStatusChangeEmail($comment, $this->field, $this->frontendFormsConfig);
                                    }
                                }
                                $session->message($this->_('Your changes have been saved'));
                            } else {
                                $session->warning($this->_('An error occured during the saving process and the data could not be saved.'));
                            }
                        } catch (Exception $e) {
                            // Do something with the Exception values
                        }
                    }
                }
                // render out form without processing
                $out .= $form->render();
            } else {
                $out = '<p>' . $this->_('Sorry, but a comment with the data provided does not exist.') . '</p>';
            }
            return $out;
        }

        /**
         * Create and render the AdminTable containing the comments of a selected FrontendForms field
         * @param \ProcessWire\WireArray $comments
         * @param \ProcessWire\InputfieldForm $form
         * @return string
         * @throws \ProcessWire\WireException
         * @throws \ProcessWire\WirePermissionException
         */
        public function ___executeTable(WireArray $comments, InputfieldForm $form): string
        {

            // get the list of date formats to choose one for the creation date
            $dateFormats = wire('datetime')->getDateFormats();

            // create the table
            $table = $this->modules->get('MarkupAdminDataTable');
            $table->setEncodeEntities(false);
            $table->setColNotSortable(0);
            $table->setColNotSortable(5);
            $table->id = 'comment-manager-table';

            // table head
            $table->headerRow([
                '#',
                $this->_('Data'),
                $this->_('Text'),
                $this->_('Status')
            ]);

            foreach ($comments as $commentArray) {

                // table body
                foreach ($commentArray as $key => $comment) {

                    // Create hidden field containing the ID of the comment
                    $commentId = wire('modules')->get('InputfieldHidden');
                    $commentIdName = 'id_' . $comment->id;
                    $commentId->attr('commentid+name', $commentIdName);
                    $commentId->value = $comment->id;

                    // Create the status select field
                    $selectStatus = wire('modules')->get('InputfieldSelect');
                    $selectName = 'status_' . $comment->id;
                    $selectStatus->attr('id+name', $selectName);
                    $statusOptions = [
                        FieldtypeFrontendComments::pendingApproval => $this->_('Waiting for approval'),
                        FieldtypeFrontendComments::approved => $this->_('Approved'),
                        FieldtypeFrontendComments::spam => $this->_('SPAM'),
                        FieldtypeFrontendComments::spamReplies => $this->_('SPAM, but has children'),
                    ];
                    $selectStatus->addOptions($statusOptions);
                    $value = (wire('input')->post->$selectName) ?? $comment->status;
                    $selectStatus->attr('value', $value);

                    $button = wire('modules')->get('InputfieldButton');
                    $button->setSecondary();
                    $button->attr('data-buttons', 'button#submitdetail');
                    $button->attr('data-autoclose', '');
                    $button->attr('data-href', wire('input')->url() . 'detail?commentid=' . $comment->id . '&pageid=' . $comment->getPage()->id . '&fieldid=' . $comment->getField()->id);
                    $button->addClass('pw-modal');
                    $button->text = $this->_('Edit full comment');
                    $button->icon = 'pencil';
                    $button->value = $comment->id;

                    $dataTable = '<table class="fc-data-table">
                        <tr><td class="fc-table-label">' . $this->_('Created') . '</td><td>' . wire('datetime')->date($dateFormats[4], $comment['created']) . '</td></tr>
                        <tr><td class="fc-table-label">' . $this->_('Page') . '</td><td><a href="' . $comment->getPage()->url . '" target="_blank">' . $comment->getPage()->title . '</a></td></tr>
                        <tr><td class="fc-table-label">' . $this->_('Author') . '</td><td>' . $comment->author . '</td></tr>
                        <tr><td class="fc-table-label">' . $this->_('Email') . '</td><td>' . $comment->email . '</td></tr>
                    </table>
                    <div class="fc-edit-comment">' . $button->render() . '</div>';

                    $table->row([
                        $key + 1,
                        $dataTable,
                        $comment->text,
                        $selectStatus->render(),
                        $commentId->render()
                    ]);
                }
            }
            return $table->render();
        }

        /** Helper function to group comments by field and page
         * @param $arr
         * @param $criteria
         * @return array
         */
        protected function groupBy($arr, $criteria): array
        {
            return array_reduce($arr, function ($accumulator, $item) use ($criteria) {
                $key = (is_callable($criteria)) ? $criteria($item) : $item[$criteria];
                if (!array_key_exists($key, $accumulator)) {
                    $accumulator[$key] = [];
                }
                array_push($accumulator[$key], $item);
                return $accumulator;
            }, []);
        }

        /**
         * WireArray to get all CommentArrays and their comments according to selectors and limits
         * @param \ProcessWire\Field $field
         * @param array|null $selectors
         * @param int $limit
         * @return \ProcessWire\WireArray
         * @throws \ProcessWire\WireException
         */
        protected function findComments(Field $field, array|null $selectors = [], int $limit = 0): WireArray
        {

            $allComments = new WireArray();

            // If no FrontendCommentFields are installed, return an empty WireArray
            if (!$this->commentFields->count)
                return $allComments;

            // Get all values of the given FrontendComments field table
            $table = $field->getTable();
            $query = ["SELECT * FROM $table"];

            // add selectors if present
            if ($selectors) {
                $query[] = 'WHERE ' . implode(' AND ', $selectors);
            }

            // sort all results by creation date ascending
            $query[] = "ORDER BY created";

            // set the limit of comment saccording to the filter settings
            if ($limit != 0) {
                $query[] = "LIMIT $limit";
            }

            $queryString = implode(' ', $query);

            // try to query the database
            try {

                $sql = wire('database')->prepare($queryString);
                $sql->execute();
                $commentsFound = $sql->fetchAll();

                // comments have been found
                if ($commentsFound) {
                    $groupedComments = $this->groupBy($commentsFound, 'pages_id');
                    foreach ($groupedComments as $pageId => $data) {
                        $pageComments = new CommentArray();
                        $pageComments->setPage(wire('pages')->get($pageId));
                        $pageComments->setField($field);
                        foreach ($data as $c) {
                            $pageComment = new Comment($c, $pageComments);
                            // Add the comment to the CommentArray
                            $pageComments->add($pageComment);
                        }
                        // add the CommentArray to the WireArray
                        $allComments->add($pageComments);
                    }
                }
            } catch (Exception $e) {

            }
            return $allComments; // return the WireArray containing all CommentArrays
        }

        /**
         * @param \ProcessWire\Field $field
         * @param \FrontendComments\Comment $comment
         * @param int $newStatus
         * @return bool
         * @throws \ProcessWire\WireException
         */
        protected function saveComment(Field $field, Comment $comment, int $newStatus): bool
        {
            // status has been changed
            $table = $field->getTable();

            // set value for the spam_update column
            $spam_update = NULL;

            // check if the status has been set to spam
            if ($newStatus == '2')  {
                $spam_update = time();
            }
            // check if comment has children at the moment - if yes set spam_update to null again
            if (($comment->getReplies()->count) && ($newStatus == '2')) {
                $spam_update = NULL;
                $newStatus = '3'; // set new status to 3 (SPAM, but has children) to prevent deletion of the comment
            }

            $sql = "UPDATE $table SET status=:status, spam_update=:spam_update WHERE id=:id";

            // try to save the data to the database
            try {
                $query = wire('database')->prepare($sql);
                $query->bindValue(":status", $newStatus, PDO::PARAM_INT);
                $query->bindValue(":spam_update", $spam_update, PDO::PARAM_INT); // remove time stamp if present
                $query->bindValue(":id", $comment->id, PDO::PARAM_INT);
                return $query->execute();
            } catch (Exception $e) {
                return false;
            }
        }

        /**
         * Output the new table according to the filters set
         * @param \FrontendComments\CommentArray $totalComments
         * @return void
         * @throws \ProcessWire\WireException
         * @throws \ProcessWire\WirePermissionException
         */
        public function ___executeComments(WireArray $totalComments): void
        {
            if ($this->input->post('submit')) {

                // ID of the selected FieldtypeComments field from the filter
                $fieldID = (int)$this->input->post('fc-commentsfield');

                // Set new $field property according to the select POST value
                $field = wire('fields')->get($fieldID);

                // array that should hold all updated commentIDs for later usage
                $updates = [];

                // get all comment IDs from the POST array
                $commentids = $this->input->post->find('id_*');
                foreach ($commentids as $id) {

                    foreach ($totalComments as $comments) {

                        // get the comment with this id
                        $comment = $comments->findOne($id);

                        if ($comment) {

                            // create new CommentArray -> needed for sending notification email
                            $commentArray = new CommentArray();
                            $commentArray->setField($field);
                            $commentArray->setPage(wire('pages')->get($comment->pages_id));
                            $commentArray->add($comment);

                            // Compare old and new status if something has been changed
                            $oldStatus = $comment->status;
                            $newStatus = (int)$this->input->post('status_' . $id);

                            if ($oldStatus != $newStatus) {

                                if($this->saveComment($field, $comment, $newStatus)){
                                    // set new status to the comment
                                    $comment->status = $newStatus;
                                    $updates[] = $id;

                                    if (in_array($comment->status, [FieldtypeFrontendComments::approved, FieldtypeFrontendComments::spam])) {

                                        $notification = new Notifications($commentArray);
                                        // send email about the status change
                                        $notification->sendStatusChangeEmail($comment, $field, $this->frontendFormsConfig);
                                    }
                                }

                                /*
                                // status has been changed
                                $table = $field->getTable();

                                // set value for the spam_update column
                                $spam_update = NULL;

                                // check if status has been set to spam
                                if ($newStatus == '2')  {
                                    $spam_update = time();
                                }
                                // check if comment has children at the moment - if yes set spam_update to null again
                                if (($comment->getReplies()->count) && ($newStatus == '2')) {
                                    $spam_update = NULL;
                                    $newStatus = '3'; // set new status to 3 (SPAM, but has children) to prevent deletion of the comment
                                }

                                $sql = "UPDATE $table SET status=:status, spam_update=:spam_update WHERE id=:id";

                                // try to save the data to the database
                                try {
                                    $query = wire('database')->prepare($sql);
                                    $query->bindValue(":status", $newStatus, PDO::PARAM_INT);
                                    $query->bindValue(":spam_update", $spam_update, PDO::PARAM_INT); // remove time stamp if present
                                    $query->bindValue(":id", $comment->id, PDO::PARAM_INT);

                                    // execute the query to save the comment in the database
                                    if ($query->execute()) {

                                        // set new status to the comment
                                        $comment->status = $newStatus;
                                        $updates[] = $id;

                                        if (in_array($comment->status, [FieldtypeFrontendComments::approved, FieldtypeFrontendComments::spam])) {

                                            $notification = new Notifications($commentArray);
                                            // add new status to the comment
                                            $notification->sendStatusChangeEmail($comment, $field, $this->frontendFormsConfig);
                                        }
                                    }
                                } catch (Exception $e) {

                                }
                                */

                            }
                        }
                    }
                }

                // output a message
                if ($updates) {
                    $number = count($updates);
                    $text = _n($this->_('The status of 1 comment has been updated'),
                        $this->_('The status of %s comments has been updated'), $number);
                    $this->wire->message(sprintf($text, $number));
                } else {
                    // no updates
                    $this->wire->message($this->_('No comments have been updated'));
                }

            }
        }

        /**
         * Get the WireArray containing all FrontendComments fields as objects
         * @return \ProcessWire\WireArray
         * @throws \ProcessWire\WireException
         */
        public function getCommentFields(): WireArray
        {
            $commentFields = new WireArray();
            foreach (wire('fields')->findByType('FieldtypeFrontendComments') as $field) {
                $commentFields->add($field);
            }
            return $commentFields;
        }

        /**
         * Get the total number of comments limited by one or more selectors for a given FrontendComments field
         * @param \ProcessWire\Field $field
         * @param array $selector
         * @return int
         * @throws \ProcessWire\WireException
         */
        public function getNumberOfCommentsBySelector(Field $field, array $selector = []): int
        {
            $number = 0;
            foreach ($this->findComments($field, $selector) as $comment) {
                $number += $comment->count;
            }
            return $number;
        }

        /**
         * Get the total number of comments for a given FrontendComments field
         * @param \ProcessWire\Field $field
         * @return int
         * @throws \ProcessWire\WireException
         */
        public function getTotal(Field $field): int
        {
            return $this->getNumberOfCommentsBySelector($field);
        }

        /**
         * Get number of comments with status approved for a certain FrontendComments field
         * @param \ProcessWire\Field $field
         * @return int
         * @throws \ProcessWire\WireException
         */
        public function getApproved(Field $field): int
        {
            return $this->getNumberOfCommentsBySelector($field, ['status=' . FieldtypeFrontendComments::approved]);
        }

        /**
         * Get number of comments with status waiting for approval for a certain FrontendComments field
         * @param \ProcessWire\Field $field
         * @return int
         * @throws \ProcessWire\WireException
         */
        public function getWaitingApproval(Field $field): int
        {
            return $this->getNumberOfCommentsBySelector($field, ['status=' . FieldtypeFrontendComments::pendingApproval]);
        }

        /**
         * Get number of comments with status waiting for approval for a certain FrontendComments field
         * @param \ProcessWire\Field $field
         * @return int
         * @throws \ProcessWire\WireException
         */
        public function getSpam(Field $field): int
        {
            return $this->getNumberOfCommentsBySelector($field, ['status=' . FieldtypeFrontendComments::spam]);
        }

        /**
         * Create and output the filter form including the table for the comments
         * @return string
         * @throws \ProcessWire\WireException
         * @throws \ProcessWire\WirePermissionException
         */
        public function ___execute(): string
        {

            // No FrontendComments field exists
            if (!$this->commentFields->count)
                return '';

            // get all comments of this field
            $totalComments = $this->findComments($this->field); // all comments - no limit
            $comments = $this->findComments($this->field, null, $this->defaultNumber); // default number of comments

            $selectors = [];

            $out = '<div id="frontendcomments-manager">';

            $form = wire('modules')->get('InputfieldForm');

            // create statistic fieldset
            $statisticFieldset = wire('modules')->get('InputfieldFieldset');
            $statisticFieldset->label = $this->_('Comment statistics');
            $statisticFieldset->columnWidth = 100;
            $statisticFieldset->icon = 'fa-bar-chart';
            $statisticFieldset->collapsed = Inputfield::collapsedYes;

            $commentfieldsdata = $this->modules->get('InputfieldMarkup');

            // Data table for all FieldtypeComments fields
            $datatable = wire('modules')->get('MarkupAdminDataTable');
            $datatable->setEncodeEntities(false);
            $datatable->id = 'fields-data-table';

            $datatable->headerRow([
                '#',
                $this->_('Field name'),
                $this->_('Total number of comments'),
                $this->_('Number of approved comments'),
                $this->_('Number of comments waiting for approval'),
                $this->_('Number of comments declared as SPAM'),
            ]);

            foreach ($this->commentFields as $key => $commentField) {

                $datatable->row([
                    $key + 1,
                    $commentField->name,
                    $this->getTotal($commentField),
                    $this->getApproved($commentField),
                    $this->getWaitingApproval($commentField),
                    $this->getSpam($commentField)
                ]);
            }
            $commentfieldsdata->value = $datatable->render();
            $statisticFieldset->add($commentfieldsdata);
            $form->add($statisticFieldset);

            // create comment managing fieldset
            // create filter fieldset
            $managingFieldset = wire('modules')->get('InputfieldFieldset');
            $managingFieldset->label = $this->_('Manage the comments');
            $managingFieldset->columnWidth = 100;
            $managingFieldset->icon = 'fa-cog';


            $markup = '';

            // Filter select for the FrontendCommentsField
            $commentsField = $this->modules->get('InputfieldSelect');
            $commentsField->label = $this->_('Comments field');
            $commentsField->attr('id+name', 'fc-commentsfield');
            $commentsField->required = 1;
            foreach ($this->getCommentFields() as $field) {
                $label = $field->name;
                $unapproved = $this->getWaitingApproval($field);
                if ($unapproved) {
                    $text = $this->_n($this->_('comment is'),
                        $this->_('comments are'), $unapproved);
                    $label = $label . ' (' . $unapproved . ' ' . $text . ' ' . $this->_('waiting for approval') . ')';
                }
                $commentsField->addOption($field->id, $label);
            }
            $commentsField->defaultValue = $this->getCommentFields()->first()->id;
            $commentsField->value = wire('input')->post->fc_commentsfield;
            $markup .= $commentsField->render();

            // Filters select for the number of comments displayed
            $numberField = $this->modules->get('InputfieldSelect');
            $numberField->label = $this->_('Number of comments to display');
            $numberField->attr('id+name', 'fc-filternumber');
            $numberField->required = 1;
            $options = [
                '1' => '1',
                '2' => '2',
                '10' => '10',
                '20' => '20',
                '30' => '30',
                '40' => '40',
                '50' => '50',
                'all' => $this->_('all'),
            ];
            $numberField->addOptions($options);
            $numberField->value = wire('input')->post->filternumber;
            $numberField->defaultValue = $this->defaultNumber;
            $markup .= $numberField->render();

            // Filter select for the status of the comments
            $statusField = $this->modules->get('InputfieldSelect');
            $statusField->label = $this->_('Status of comments');
            $statusField->attr('id+name', 'filterstatus');
            $statusField->required = 1;
            $options = [
                FieldtypeFrontendComments::pendingApproval => $this->_('Waiting approval'),
                FieldtypeFrontendComments::approved => $this->_('Approved'),
                FieldtypeFrontendComments::spam => $this->_('SPAM'),
                '3' => $this->_('all'),
            ];
            $statusField->addOptions($options);
            $statusField->defaultValue = 3;
            $markup .= $statusField->render();

            $filter = wire('modules')->get('InputfieldMarkup');
            $filter->markupText = $markup;
            $managingFieldset->add($filter);

            $tableout = '';
            // create table
            $tableField = $this->modules->get('InputfieldMarkup');

            // create new table content after Ajax call
            if ($this->wire('config')->ajax) {

                // Field
                $fieldID = $this->input->get('fc-commentsfield');
                // get the field object
                $this->field = $this->commentFields->findOne('id=' . $fieldID);

                // Number of comments inside the table
                $number = $this->input->get('fc-filternumber');
                $number = wire('sanitizer')->int($number);

                // Status of the comments
                $status = $this->input->get('filterstatus');
                $status = wire('sanitizer')->int($status, ['min' => 0, 'max' => 3]);

                if ($status < 3) { // value is not "all"
                    $selectors[] = 'status=' . $status;
                }

                // find all comments according to the filter settings
                $comments = $this->findComments($this->field, $selectors, $number);

                if ($comments->count) {
                    // create the new table containing the comments found
                    $tableMarkup = $this->___executeTable($comments, $form);
                } else {
                    // create only text
                    if ($this->getTotal($this->field)) {
                        $text = $this->_('No comments match your selected filter criteria.');
                    } else {
                        $text = $this->_('This comment field does not contain any comments.');
                    }
                    $tableMarkup = '<div class="fc-nocomments">' . $text . '</div>';

                }

                $tableout .= '<div id="ajax-comments-table" data-number="' . $this->getTotal($this->field) . '">' . $tableMarkup . '</div>';
            }

            $tableMarkup = $this->___executeTable($comments, $form);

            if ($comments->count) {
                $tableout .= '<div class="fc-totalcount">' . sprintf($this->_('Total number of comments: %s'), '<span id="fc-totalnumber">' . $this->getTotal($this->field) . '</span>') . '</div>';
                if ($this->getTotal($this->field) > 0) {
                    $tableout .= '<p id="changetext">' . $this->_('Change the status of each comment to your needs and press the save button below to save your changes.') . '</p>';
                }
                $tableout .= '<div id="comments-table">' . $tableMarkup . '</div>';
            } else {
                // add only text
                $tableout .= '<div id="comments-table" class="fc-nocomments">' . $this->_('There are no comments to display.') . '</div>';
            }

            $tableField->value = $tableout;
            $managingFieldset->add($tableField);

            // add submit button
            if ($comments->count) {
                // show save button only if there are comments
                $button = $this->modules->get('InputfieldSubmit');
                $button->value = 'Save changes';
                $button->icon = 'floppy-o';
                $managingFieldset->add($button);
            }

            $form->add($managingFieldset);

            $out .= $form->render();
            $out .= '</div>';

            $this->___executeComments($totalComments);

            return $out;
        }

    }
